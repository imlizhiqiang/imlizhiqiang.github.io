https://www.cnblogs.com/zxf330301/p/6534643.html

PO 是与数据库记录严格地一一对应，即使这个表是个中间表，是个视图，等等。

DO 是领域对象，类似于 entity 的东西，他对应的是实体，比如老师和学生，它们之间的关联关系是有个表的，有个 PO，但是没有 DO，因为不存在这个实体，另外，实体不是简单地只有 getter 和 setter，还有一些其他的方法。

这个设计是基于领域模型 DDD 的，我本人不太喜欢这种设计风格。我认为这是将“对象是现实中实体的映射”这个观点发展到极致的产物，我并不完全同意这个前提，我认为对象的意义更多地在于程序中，而非是现实中。对象不过是一个封装体而已。

比如教师一定有个 teach 方法

这种设计认为功能一定依附于某个实体，且这个实体有明确的意义，这种风格就叫做“更加面向对象”。我个人更喜欢一种松散的面向对象风格，即对象只是一个盒子，对象本身并没有实体意义。

---

应该克制使用 DDD，不到万不得已，业务逻辑非常复杂繁琐的时候，就先不要使用，前期保持较低的抽象层级，保持代码简洁易于理解，随着后续的业务需求的增加再让架构慢慢演进。

过早地，过多地使用 DDD 会给一线开发人员增加繁重的心智负担，使他们在各种纷繁复杂的 model 之间来回转换，很快就变得非常疲惫。

---

一个人，或者一个团队，所能感知或处理的复杂度是有上限的，当系统变得过分复杂，那么所有人都不能了解系统，也就不能控制系统。架构要解决的问题就是在系统规模上升时，如何保持其复杂度不变，或者只是有限地升高。

所谓封装，其实就是隔离复杂度的手段，通过多层次的封装，我们可以得到一个清晰的抽象层级，从而可以在不同的粒度上了解系统的整体及部分。

---

关于微服务之间的拆分:要追求细粒度，同时要保持服务间通信不能太密集。这是一个平衡，应该拆分微服务直到下一次拆分将使得通信迅速密集为止。

---

-   PO（持久化对象） 等价于 entity（实体）。在实践中我根据不同的持久层框架来对应选择不同的命名，如果使用 mybatis，对应 po 命名，如果使用 JPA，对应 entity 命名。
    -   注意 PO 不是来自于 DDD 的概念而是来自于 ORM 的概念。在 DDD 中与之类似的概念是 DO。
    -   po 与 dao 层绑定，在 dao 层的代码中，永远不出现 po 以外的其他 model。
    -   如果使用了 JPA，更加要严格限制 entity 的使用，因为 hibernate 的 session 会在内存中持久化对象，在预期之外的地方使用 entity 可能导致对象的属性值被意外修改。
    -   如果在 dao 层中某个复杂查询查出了一个组合多张不同表中字段的结果，该如何封装呢？JPA 面对这种需求时使用@Query 注解，将返回结果视为 `List<Object[]>`，可以将对应结果类的构造函数写进 select 语句中，让框架完成填充。命名可以使用 xxxResult 的形式。或者不提供任何封装类，直接在 dao 层返回`List<Object[]>`。
-   DTO 存在于 controller 层与 service 层之间，service 层从 controller 接收和返回 controller 的对象全部都是 DTO，与之相对的，service 层传给 dao 的是 entity，从 dao 返回来的也是 entity，或者`List<Object[]>`。
-   VO（value object 值对象） 是 controller 层返回给前端的封装对象。
-   Body 是前端给 controller 传递的复杂参数，这个命名是我个人推荐的，因为一般这样的参数在 controller 层中都是使用@RequestBody 注解接收。
-   DO 很特殊，不同于上面所有的 model，它不是简单的 pojo，它通常包含一些业务方法。甚至 DO 可能是真正提供业务方法的实体，service 层只是调用者。
    -   在实践中，DO 只在 service 层中使用，且不会暴露给 controller 和 dao 层。
    -   DO 主要负责在业务对象的属性上进行一些操作，比如给用户的密码加密，或者检查账户的余额，等等。这些操作会体现在属性的值上。
    -   另外从环境论的视角观察 DO，它的核心在于方法，属性只作为依赖，由此，DO 中的属性都应该是 final 的。
    -   注意 DO 与 PO 都会对应“业务实体”，但 PO 严格对应表，而 DO 则对应业务，比如一个用户的全部信息散落在三张表中，此时会有三个 PO，但只有一个 DO。
    -   早期设计中 DO 直接负责与数据库的交互，现在这部分已经单独抽出一个 dao 层。因为有 ORM 框架的存在，实践中数据库交互代码一般直接以接口形式存在，如果写在一个类中会很混乱。所以现在不应该再在 DO 中实现持久化代码。
-   BO（business object） 更为少见，它可以被看做是“小型的 service”，也是业务方法的封装对象，假如一个 service 的方法较为复杂，需要调用其他的数个 service 来实现的时候，这些被调用的“小 service”就是 BO。
    -   BO 本身是 DDD 中的概念，实践中完全可以没有，业务逻辑全部使用 service。
    -   BO 封装的是“业务逻辑”，或者说是“业务流程”。想象一条流水线。
    -   BO 甚至可能没有属性，表现得像是一个工具类，可以用来封装不同 model 之间的转换，比如 service 的一个方法接收 dto 作为参数，然后创建一个 entity 并保存，然后再返回一个 dto 作为结果，这之间发生的对象拼装过程可以由 DO 来完成。

总结：

-   VO,PO,DTO 这三种 model 会出现在层与层之间，它们都是 POJO，而 DO 和 BO 只在 service 层中出现，它们包含业务方法。
-   一般来说 PO 是肯定要有的，VO 和 DTO 在非常简单的小业务中可能直接就通用了（保留 DTO 放弃 VO），但稍微复杂一些的业务还是会区分出来。
-   service 层是业务的实现部分。dao 层不负责任何逻辑。controller 层只进行参数校验之类的前端逻辑，不应该涉及任何业务。

---

概念：
VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。
DTO（Data Transfer Object）：数据传输对象，这个概念来源于 J2EE 的设计模式，原来的目的是为了 EJB 的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。
DO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。
PO（Persistent Object）：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应 PO 的一个（或若干个）属性。

VO 与 DTO 的区别
大家可能会有个疑问（在笔者参与的项目中，很多程序员也有相同的疑惑）：既然 DTO 是展示层与服务层之间传递数据的对象，为什么还需要一个 VO 呢？对！对于绝大部分的应用场景来说，DTO 和 VO 的属性值基本是一致的，而且他们通常都是 POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在 VO 和 DTO，因为两者有着本质的区别，DTO 代表服务层需要接收的数据和返回的数据，而 VO 代表展示层需要显示的数据。
用一个例子来说明可能会比较容易理解：例如服务层有一个 getUser 的方法返回一个系统用户，其中有一个属性是 gender(性别)，对于服务层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的 DTO，不应该出现与表现形式的耦合。
理论归理论，这到底还是分析设计层面的思维，是否在实现层面必须这样做呢？一刀切的做法往往会得不偿失，下面我马上会分析应用中如何做出正确的选择。

VO 与 DTO 的应用
上面只是用了一个简单的例子来说明 VO 与 DTO 在概念上的区别，本节将会告诉你如何在应用中做出正确的选择。
在以下才场景中，我们可以考虑把 VO 与 DTO 二合为一（注意：是实现层面）：
当需求非常清晰稳定，而且客户端很明确只有一个的时候，没有必要把 VO 和 DTO 区分开来，这时候 VO 可以退隐，用一个 DTO 即可，为什么是 VO 退隐而不是 DTO？回到设计层面，服务层的职责依然不应该与展示层耦合，所以，对于前面的例子，你很容易理解，DTO 对于“性别”来说，依然不能用“帅哥美女”，这个转换应该依赖于页面的脚本（如 JavaScript）或其他机制（JSTL、EL、CSS）
即使客户端可以进行定制，或者存在多个不同的客户端，如果客户端能够用某种技术（脚本或其他机制）实现转换，同样可以让 VO 退隐

以下场景需要优先考虑 VO、DTO 并存：
上述场景的反面场景
因为某种技术原因，比如某个框架（如 Flex）提供自动把 POJO 转换为 UI 中某些 Field 时，可以考虑在实现层面定义出 VO，这个权衡完全取决于使用框架的自动转换能力带来的开发和维护效率提升与设计多一个 VO 所多做的事情带来的开发和维护效率的下降之间的比对。
如果页面出现一个“大视图”，而组成这个大视图的所有数据需要调用多个服务，返回多个 DTO 来组装（当然，这同样可以通过服务层提供一次性返回一个大视图的 DTO 来取代，但在服务层提供一个这样的方法是否合适，需要在设计层面进行权衡）。

DTO 与 DO 的区别
首先是概念上的区别，DTO 是展示层和服务层之间的数据传输对象（可以认为是两者之间的协议），而 DO 是对现实世界各种业务角色的抽象，这就引出了两者在数据上的区别，例如 UserInfo 和 User（对于 DTO 和 DO 的命名规则，请参见笔者前面的一篇博文），对于一个 getUser 方法来说，本质上它永远不应该返回用户的密码，因此 UserInfo 至少比 User 少一个 password 的数据。而在领域驱动设计中，正如第一篇系列文章所说，DO 不是简单的 POJO，它具有领域业务逻辑。

DTO 与 DO 的应用
从上一节的例子中，细心的读者可能会发现问题：既然 getUser 方法返回的 UserInfo 不应该包含 password，那么就不应该存在 password 这个属性定义，但如果同时有一个 createUser 的方法，传入的 UserInfo 需要包含用户的 password，怎么办？在设计层面，展示层向服务层传递的 DTO 与服务层返回给展示层的 DTO 在概念上是不同的，但在实现层面，我们通常很少会这样做（定义两个 UserInfo，甚至更多），因为这样做并不见得很明智，我们完全可以设计一个完全兼容的 DTO，在服务层接收数据的时候，不该由展示层设置的属性（如订单的总价应该由其单价、数量、折扣等决定），无论展示层是否设置，服务层都一概忽略，而在服务层返回数据时，不该返回的数据（如用户密码），就不设置对应的属性。
对于 DO 来说，还有一点需要说明：为什么不在服务层中直接返回 DO 呢？这样可以省去 DTO 的编码和转换工作，原因如下：
两者在本质上的区别可能导致彼此并不一一对应，一个 DTO 可能对应多个 DO，反之亦然，甚至两者存在多对多的关系。
DO 具有一些不应该让展示层知道的数据
DO 具有业务方法，如果直接把 DO 传递给展示层，展示层的代码就可以绕过服务层直接调用它不应该访问的操作，对于基于 AOP 拦截服务层来进行访问控制的机制来说，这问题尤为突出，而在展示层调用 DO 的业务方法也会因为事务的问题，让事务难以控制。
对于某些 ORM 框架（如 Hibernate）来说，通常会使用“延迟加载”技术，如果直接把 DO 暴露给展示层，对于大部分情况，展示层不在事务范围之内（Open session in view 在大部分情况下不是一种值得推崇的设计），如果其尝试在 Session 关闭的情况下获取一个未加载的关联对象，会出现运行时异常（对于 Hibernate 来说，就是 LazyInitiliaztionException）。
从设计层面来说，展示层依赖于服务层，服务层依赖于领域层，如果把 DO 暴露出去，就会导致展示层直接依赖于领域层，这虽然依然是单向依赖，但这种跨层依赖会导致不必要的耦合。

对于 DTO 来说，也有一点必须进行说明，就是 DTO 应该是一个“扁平的二维对象”，举个例子来说明：如果 User 会关联若干个其他实体（例如 Address、Account、Region 等），那么 getUser()返回的 UserInfo，是否就需要把其关联的对象的 DTO 都一并返回呢？如果这样的话，必然导致数据传输量的大增，对于分布式应用来说，由于涉及数据在网络上的传输、序列化和反序列化，这种设计更不可接受。如果 getUser 除了要返回 User 的基本信息外，还需要返回一个 AccountId、AccountName、RegionId、RegionName，那么，请把这些属性定义到 UserInfo 中，把一个“立体”的对象树“压扁”成一个“扁平的二维对象”，笔者目前参与的项目是一个分布式系统，该系统不管三七二十一，把一个对象的所有关联对象都转换为相同结构的 DTO 对象树并返回，导致性能非常的慢。

DO 与 PO 的区别
DO 和 PO 在绝大部分情况下是一一对应的，PO 是只含有 get/set 方法的 POJO，但某些场景还是能反映出两者在概念上存在本质的区别：
DO 在某些场景下不需要进行显式的持久化，例如利用策略模式设计的商品折扣策略，会衍生出折扣策略的接口和不同折扣策略实现类，这些折扣策略实现类可以算是 DO，但它们只驻留在静态内存，不需要持久化到持久层，因此，这类 DO 是不存在对应的 PO 的。
同样的道理，某些场景下，PO 也没有对应的 DO，例如老师 Teacher 和学生 Student 存在多对多的关系，在关系数据库中，这种关系需要表现为一个中间表，也就对应有一个 TeacherAndStudentPO 的 PO，但这个 PO 在业务领域没有任何现实的意义，它完全不能与任何 DO 对应上。这里要特别声明，并不是所有多对多关系都没有业务含义，这跟具体业务场景有关，例如：两个 PO 之间的关系会影响具体业务，并且这种关系存在多种类型，那么这种多对多关系也应该表现为一个 DO，又如：“角色”与“资源”之间存在多对多关系，而这种关系很明显会表现为一个 DO——“权限”。
某些情况下，为了某种持久化策略或者性能的考虑，一个 PO 可能对应多个 DO，反之亦然。例如客户 Customer 有其联系信息 Contacts，这里是两个一对一关系的 DO，但可能出于性能的考虑（极端情况，权作举例），为了减少数据库的连接查询操作，把 Customer 和 Contacts 两个 DO 数据合并到一张数据表中。反过来，如果一本图书 Book，有一个属性是封面 cover，但该属性是一副图片的二进制数据，而某些查询操作不希望把 cover 一并加载，从而减轻磁盘 IO 开销，同时假设 ORM 框架不支持属性级别的延迟加载，那么就需要考虑把 cover 独立到一张数据表中去，这样就形成一个 DO 对应对个 PO 的情况。
PO 的某些属性值对于 DO 没有任何意义，这些属性值可能是为了解决某些持久化策略而存在的数据，例如为了实现“乐观锁”，PO 存在一个 version 的属性，这个 version 对于 DO 来说是没有任何业务意义的，它不应该在 DO 中存在。同理，DO 中也可能存在不需要持久化的属性。

DO 与 PO 的应用
由于 ORM 框架的功能非常强大而大行其道，而且 JavaEE 也推出了 JPA 规范，现在的业务应用开发，基本上不需要区分 DO 与 PO，PO 完全可以通过 JPA，Hibernate Annotations/hbm 隐藏在 DO 之中。虽然如此，但有些问题我们还必须注意：
对于 DO 中不需要持久化的属性，需要通过 ORM 显式的声明，如：在 JPA 中，可以利用@Transient 声明。
对于 PO 中为了某种持久化策略而存在的属性，例如 version，由于 DO、PO 合并了，必须在 DO 中声明，但由于这个属性对 DO 是没有任何业务意义的，需要让该属性对外隐藏起来，最常见的做法是把该属性的 get/set 方法私有化，甚至不提供 get/set 方法，但对于 Hibernate 来说，这需要特别注意，由于 Hibernate 从数据库读取数据转换为 DO 时，是利用反射机制先调用 DO 的空参数构造函数构造 DO 实例，然后再利用 JavaBean 的规范反射出 set 方法来为每个属性设值，如果不显式声明 set 方法，或把 set 方法设置为 private，都会导致 Hibernate 无法初始化 DO，从而出现运行时异常，可行的做法是把属性的 set 方法设置为 protected。
对于一个 DO 对应多个 PO，或者一个 PO 对应多个 DO 的场景，以及属性级别的延迟加载，Hibernate 都提供了很好的支持，请参考 Hibnate 的相关资料。
————————————————
版权声明：本文为 CSDN 博主「zjrbiancheng」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zjrbiancheng/article/details/6253232
